%% -*- erlang -*-
% Licensed under the Apache License, Version 2.0 (the "License"); you may not
% use this file except in compliance with the License. You may obtain a copy of
% the License at
%
%   http://www.apache.org/licenses/LICENSE-2.0
%
% Unless required by applicable law or agreed to in writing, software
% distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
% WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
% License for the specific language governing permissions and limitations under
% the License.

%
% Blacklist some bad releases.
%
{ok, Version} = file:read_file(filename:join(
    [code:root_dir(), "releases", erlang:system_info(otp_release), "OTP_VERSION"]
)).

% Version may be binary if file has /n at end :(
% there is no string:trim/1 in Erlang 19 :(
VerString = case Version of
    V when is_binary(V) -> string:strip(binary_to_list(V), right, $\n);
    _ -> string:strip(Version, right, $\n)
end.
VerList = lists:map(fun(X) -> {Int, _} = string:to_integer(X), Int end,
    string:tokens(VerString, ".")).

DisplayMsg = fun(Msg, Args) ->
    Base = iolist_to_binary(io_lib:format(Msg, Args)),
    Lines = binary:split(Base, <<"\n">>, [global]),
    MaxLen = lists:foldl(fun(Line, Acc) ->
        max(Acc, size(Line))
    end, 0, Lines),
    Decoration = iolist_to_binary(["*" || _ <- lists:seq(1, MaxLen)]),
    ReNewLined = [[L, "~n"] || L <- Lines],
    NewLines = ["~n", Decoration, "~n", ReNewLined, Decoration, "~n~n"],
    MsgBin = iolist_to_binary(NewLines),
    io:format(binary_to_list(MsgBin), [])
end.

ErlangTooOld = fun(Ver) ->
    DisplayMsg(
        "This version of Erlang (~p) is too old for use with Apache CouchDB.~n~n"
        "See https://docs.couchdb.org/en/stable/install/unix.html#dependencies~n"
        "for the latest information on dependencies.",
        [Ver]
    ),
    halt(1)
end.

NotSupported = fun(Ver) ->
    DisplayMsg(
        "This version of Erlang (~p) is not officially supported by Apache~n"
        "CouchDB. While we do not officially support this version, there~n"
        "are also no known bugs or incompatibilities.~n~n"
        "See https://docs.couchdb.org/en/stable/install/unix.html#dependencies~n"
        "for the latest information on dependencies.",
        [Ver]
    )
end.

BadErlang = fun(Ver) ->
    DisplayMsg(
        "This version of Erlang (~p) is known to contain bugs that directly~n"
        "affect the correctness of Apache CouchDB.~n~n"
        "You should *NOT* use this version of Erlang.~n~n"
        "See https://docs.couchdb.org/en/stable/install/unix.html#dependencies~n"
        "for the latest information on dependencies.",
        [Ver]
    ),
    case os:getenv("TRAVIS") of
        "true" ->
            io:fwrite("Travis run, ignoring bad release. You have been warned!~n"),
            ok;
        _ ->
            halt(1)
    end
end.

case VerList of
    % Leave example around if we have to exlude specific versions
    % [22, 0, N | _] when N < 5 -> BadErlang(VerString);
    _ -> ok
end.

% Set the path to the configuration environment generated
% by `./configure`.

COUCHDB_ROOT = filename:dirname(SCRIPT).
os:putenv("COUCHDB_ROOT", COUCHDB_ROOT).

ConfigureEnv = filename:join(COUCHDB_ROOT, "config.erl").
os:putenv("COUCHDB_CONFIG", ConfigureEnv).

CouchConfig = case filelib:is_file(ConfigureEnv) of
    true ->
        {ok, Result} = file:consult(ConfigureEnv),
        Result;
    false ->
        []
end.

os:putenv("COUCHDB_APPS_CONFIG_DIR", filename:join([COUCHDB_ROOT, "rel/apps"])).


WithProper = lists:keyfind(with_proper, 1, CouchConfig) == {with_proper, true}.

OptionalDeps = case WithProper of
    true ->
        [{proper, {url, "https://github.com/proper-testing/proper"}, {tag, "v1.4"}}];
    false ->
        []
end.

DepsConfig = os:getenv("COUCHDB_DEPS", filename:join([COUCHDB_ROOT, "deps.config"])).
Deps = case filelib:is_file(DepsConfig) of
    true ->
        {ok, [DepsResult]} = file:consult(DepsConfig),
        DepsResult;
    false ->
        rebar_api:abort(lists:flatten(io_lib:format("Deps file '~s' not found~n", [DepsConfig])))
end.

InProfile = fun(Profile, Specs) ->
    lists:foldl(fun(Spec, Acc) ->
        io:format("Spec = ~p~n", [Spec]),
        Profiles = element(size(Spec), Spec),
        case lists:member(Profile, Profiles) of
            true -> [Spec | Acc];
            false -> Acc
        end
    end, [], Specs)
end.

ReleaseApps = [
    element(1, Spec)
    || Spec <- InProfile(release,
        maps:get(extra_apps, Deps, [])
        ++ maps:get(project_apps, Deps, [])
        ++ maps:get(system_apps, Deps, [])
    )].

BaseUrl = "https://github.com/apache/".

MakeDep = fun
    ({AppName, {url, Url}, Version, _Profiles}) ->
        {AppName, {git, Url, Version}};
    ({AppName, RepoName, Version, _Profiles}) ->
        Url = BaseUrl ++ "couchdb-" ++ RepoName ++ ".git",
        {AppName, {git, Url, Version}}
end.

ProjectApps = [element(1, AppSpec) || AppSpec <- maps:get(project_apps, Deps, [])].

%% Rebar3 has limitation that it can only test project applications.
%% I.e. applications in the same repository.
%% We cannot run tests for applications pulled in as a dependency.
EUnitTests = [{application, App} || App <- ProjectApps].

ProjectIncludeDirs = lists:filter(
    fun filelib:is_dir/1,
    [filename:join(["src", App, "include"]) || App <- ProjectApps]),
ProjectIncludes = [{i, Dir} || Dir <- ProjectIncludeDirs].

AddConfig = [
    {require_otp_vsn, "23|24|25"},
    {deps_error_on_conflict, true},
    {deps, lists:map(MakeDep, maps:get(extra_apps, Deps, []))},
    {plugins, [ic, erlfmt, rebar3_path_deps]},
    {erlfmt, [write]},
    {erl_opts, [
        {i, "../"},
        {d, 'COUCHDB_ERLANG_VERSION', VerString}
        | ProjectIncludes
    ]},
    {eunit_opts, [
        verbose,
        {report, {eunit_progress, [colored, profile]}},
        {report, {eunit_surefire, [{dir, "_build/test"}]}}
    ]},
    {project_app_dirs, ["src/*"]},
    %% Here we can only specify applications which are in the same repository
    %% we cannot run tests for applications pulled in as a dependency
    {eunit_tests, EUnitTests},
    {profiles, [
        {docs, [
            {docs, {git, "https://github.com/apache/couchdb-documentation", {ref, "ad82a485350889b64a53a646a27aa03e7d076b64"}}}
        ]},
        {test, [
            {extra_src_dirs, [{"test", [{recursive, true}]}]}
        ]},
        {testdev, [
            {relx, [
                {dev_mode, true},
                {include_erts, false}
            ]}
        ]},
        {db1, [{relx, [{release, {'db1', "3.2.2"}, ReleaseApps}]}]},
        {db2, [{relx, [{release, {'db2', "3.2.2"}, ReleaseApps}]}]},
        {db3, [{relx, [{release, {'db3', "3.2.2"}, ReleaseApps}]}]}
    ]},
    {dialyzer, [
        {plt_location, local},
        {plt_location, COUCHDB_ROOT},
        {plt_extra_apps, [
            asn1, compiler, crypto, inets, kernel, runtime_tools,
            sasl, setup, ssl, stdlib, syntax_tools, xmerl]},
        {warnings, [unmatched_returns, error_handling, race_conditions]}]},
    {post_hooks, [{compile, "escript support/build_js.escript"}]},
    {relx, [
        {release, {couchdb, "3.2.2"}, ReleaseApps},
        {mode, prod},
        {overlay_vars, "rel/couchdb.config"},
        {sys_config, "rel/files/sys.config"},
        {vm_args, "rel/files/vm.args"},

        {overlay, [
            {copy, "LICENSE", "LICENSE"},
            {mkdir, "var/log"},
            {copy, "rel/overlay/bin", "bin"},
            {copy, "rel/overlay/etc", "etc"},
            {copy, "src/couch/priv/couchjs", "bin/couchjs"},
            {copy, "share/server/main.js", "share/server/main.js"},
            {copy, "share/server/main-coffee.js", "share/server/main-coffee.js"},
            {copy, "src/weatherreport", "bin/weatherreport"},
            {template, "rel/overlay/etc/default.ini", "etc/default.ini"},
            {template, "rel/overlay/etc/vm.args", "etc/vm.args"},
            {template, "rel/files/couchdb.in", "bin/couchdb"},
            {template, "rel/files/couchdb.cmd.in", "bin/couchdb.cmd"}
        ]}
    ]}
].

io:format("AddConfig = ~p~n", [AddConfig]).

lists:foldl(fun({K, V}, CfgAcc) ->
    case lists:keyfind(K, 1, CfgAcc) of
        {K, Existent} when is_list(Existent) andalso is_list(V) ->
            lists:keystore(K, 1, CfgAcc, {K, Existent ++ V});
        false ->
            lists:keystore(K, 1, CfgAcc, {K, V})
    end
end, CONFIG, AddConfig).
